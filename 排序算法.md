# 排序算法汇总

转载自![博客园](https://www.cnblogs.com/onepixel/p/7674659.html)

## 1. 算法概述

### 1.1 算法分类

* 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破$O(n\log n)$，因此也称为**非线性时间**比较类排序
* 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为**线性时间**非比较类排序

![算法分类](https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png)

### 1.2 算法复杂度

|排序方法|时间复杂度（平均）|时间复杂度（最坏）|时间复杂度（最好）|空间复杂度|稳定性|
|-------|-----------------|---------------|-----------------|---------|------|
|冒泡排序|$O(n^2)$|$O(n^2)$|$O(n)$|$O(1)$|稳定|

**相关概念**

* 稳定：如果a原本在b前面，而a==b，排序之后a仍然在b的前面
* 不稳定：如果a原本在b前面，而a==b，排序之后a可能会出现在b的后面

## 1. 冒泡排序（Bubble Sort）

它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。

走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 

**基本思想**

* 将最大的数移到最右边，
* 如果一个数组长度为N，则只要移动N-1个数就可以，所以需要排序**N-1趟**(第一个for循环)
* 每一趟，相邻两个数进行比较交换，所以第i趟需要比较N-i次(第二个for循环)

**动图演示**

![冒泡排序动图](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)

**参考代码**
  
```c++
int main(){
  int a[10] = {10,9,8,7,6,5,4,3,2,1};
  for(int i=1;i<sizeof(a)/sizeof(a[0]);i++){ //sizeof(a)/sizeof(a[0])表示数组的长度(数组占用内存/第一个元素占用内存) 
    for(int j=0;j<sizeof(a)/sizeof(a[0])-i;j++){
      if(a[j]>a[j+1]) swap(a[j], a[j+1])
    } 
    for(int i=0;i<sizeof(a)/sizeof(a[0]);i++){
      printf("%d ", a[i]);
    }
    return 0;
} 
 ```
