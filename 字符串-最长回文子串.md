# 最长回文子串

给定一个字符串$s$，找到$s$中最长的回文子串。可以假设$s$的最大长度为1000。

## 求解方法

### 1. 直接搜索法：

**基本思想**：

最长回文子串就是在一个字符串中的那个最长的回文子串。

传统的验证回文串的方法就是两个两个的对称验证是否相等：**以每一个字符为中心，像两边扩散来寻找回文串**，这个算法的时间复杂度是 O(n*n)

* 奇数情况：
  从遍历到的位置为中心，向两边进行扩散

* 偶数情况：
  把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索
  
**参考代码（96ms）**:
```c++
class Solution {
public:
  string longestPalindrome(string s) {
    if(s.size()<2) return s;
		int start = 0, maxlen = 0;
		for(int i=0;i<s.size()-1;++i){
			Func(s, i, i, start, maxlen);
			Func(s, i, i+1, start, maxlen);
		}
		return s.substr(start, maxlen);
	}
	void Func(string s, int left, int right, int & start, int & maxlen){
		while(left >=0 && right < s.size() && s[left]==s[right]){
			--left;
			++right;
		}
		if(maxlen<right-left-1){
			start = left + 1;
			maxlen = right - left - 1;
		}
	}
};

```

**参考代码（28ms）**
```c++
class Solution {
public:
  string longestPalindrome(string s) {
    int len = s.size();
		int start = 0, maxlen = 0;
		// 奇数情况 
		for(int pos = 0; pos<len-1; ++pos){
			int left = pos - 1, right = pos + 1;
			while(left>=0 && right<len && s[left] == s[right]){
				--left; 
				++right;
			}
			if(maxlen<right-left-1){
				start = left + 1;
				maxlen = right - left - 1;
			}
		}
		string oddres = s.substr(start, maxlen);
		// 偶数情况
		start = 0, maxlen = 0;
		for(int pos = 0; pos<len-1; ++pos){
			int left = pos, right = pos + 1;
			while(left>=0 && right<len && s[left] == s[right]){
				--left;
				++right;
				if(right==len) break; 
			}
			if(maxlen<right-left-1){
				start = left + 1;
				maxlen = right - left - 1;
			}
		} 
		string evenres = s.substr(start, maxlen);
		string res = (oddres.size()>evenres.size())?oddres:evenres;
		return res;
    }
};
```
