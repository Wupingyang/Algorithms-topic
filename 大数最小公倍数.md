## 1. 基本类型范围

**计算公式**：

两个数的最小公倍数(lcm) = 两数乘积 / 两个数的最大公约数(gcd)

**计算步骤**：

- 先计算两个数的最大公约数
- 然后计算两个数的最小公倍数
- 最后计算n个数的最小公倍数

**求最大公约数算法**：

辗转相除法（欧几里得算法）

有两个整数a和b:

- a%b得余数c
- 若c==0, 则b即为两数的最大公约数
- 若c!=0, 则a=b, b=c，再返回执行步骤1

**参考代码**：
```c++
//计算两个数的最大公约数 
int gcd(int a, int b){
    	int c;
    	if(a<b) swap(a, b);
    	while(1){
    		c = a % b;
    		if(c==0) break;
    		else{
    			a = b;
    			b = c;
    		}	
    	}
    	return b;
    }
    //计算两个数的最小公倍数 
    int lcm(int a, int b){
    	int temp;
    	temp = a * b / gcd(a, b);
    	return temp;
    }
    //计算n个数的最小公倍数 
    int nlcm(int num[], int n){
    	int temp;
    	for(int i=0;i<n-1;++i){
    		temp = lcm(num[i], num[i+1]);
    		num[i+1] = temp;
    	}
    	return num[n-1];
    }
```

## 2. 大数范围

求N个数的最小公倍数的过程中，如果采用最小公倍数=乘积/最大公约数的方法，会因为结果太大，导致溢出。

**求解方法**：

- 去除因子
  - 例如1~4的最小公倍数，定义数组a[4]={1,2,3,4}
  - 因为4已经有因子2，所以a[3] = a[3]/a[2]
- 因子相乘，将替换后的数组依次相乘（大数乘法）
- 逆序输出，注意写法

**参考代码**：
```c++
    #include<cstdio>
    #include<iostream>
    #include<vector>
    using namespace std;
    
    int main(){
    	int n;
    	while(scanf("%d", &n)!=EOF){
    		int num[n];
        	//步骤1
    		for(int i=0;i<n;++i){
    			num[i] = i + 1;
    			for(int j=1; j<i;++j){
    				if(num[i] % num[j] == 0){
    					num[i] /= num[j];
    				}
    			}
    		}
            //步骤2
    		vector<int> res;
    		res.push_back(1);
    		int pos = 0;
    		while(pos<n){
    			int carry = 0;
    			for(auto & item:res){
    				int product = item * num[pos]+carry;
    				item = product % 10;
    				carry = product / 10;
    			}
    			while(carry){
    				res.push_back(carry%10);
    				carry /= 10;
    			}
    			++pos;
    		}
            //步骤3
    		for(auto it=res.rbegin();it!=res.rend();++it){
    			cout<<*it;
    		}
    		cout<<endl;
    	}
    }
```
