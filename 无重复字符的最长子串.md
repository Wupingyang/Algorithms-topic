**无重复字符的最长子串**:

给定一个字符串，找出其中不含有重复字符的**最长子串**的长度

例如："abcabcbb"，无重复的最长字串是"abc"，因此长度为3

**基本思想**：

注意这里是子串，不是子序列，所以必须是连续的。

一个字符一个字符的遍历：

* 比如 a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a
* 继续往后，又出现了一个b，则应该去掉一次出现的b
* 以此类推，最终发现最长的长度为3

**求解思路**：

* 使用**HashMap**来建立字符和其出现位置之间的映射
* 使用滑动窗口来判断字符出现的位置
  * 窗口内的都是没有重复的字符，需要尽可能的扩大窗口的大小
  * 由于窗口在不停向右滑动，所以只关心每个字符**最后出现的位置**，并建立映射
  * 窗口的右边界就是当前遍历到的字符的位置
  * 为了求出窗口的大小，需要一个变量**left**来指向滑动窗口的左边界
    * 如果当前遍历到的字符从未出现过，那么直接扩大右边界
    * 如果之前出现过，那么就分两种情况：
      * 如果不在滑动窗口内，当前字符可以加进来
      * 如果在的话，需要先在滑动窗口内去掉这个已经出现过的字符，由于**HashMap**已经保存该重复字符最后出现的位置，所以直接移动 left 指针到该位置
  * 维护一个结果**res**，每次用出现过的窗口大小来更新结果 res
  
**参考代码**：
  
```c++
class Solution {
public:
  int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> m;
    int left = -1, res = 0;
    for(int i=0;i<s.size();++i){
      if(m.count(s[i]) && m[s[i]]>left){
        left = m[s[i]];
      }
      m[s[i]] = i;
      res = max(res, i - left);
    }
    return res;
  }
};
```
